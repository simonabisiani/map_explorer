condition = "input.outlet != ''",
# Outlet Information
div(class = "sidebar-section",
div(class = "outlet-info",
htmlOutput("outlet_info")
)
),
br(),
br(),
# Spatial Coverage Metrics
div(class = "sidebar-section",
h5("Spatial Coverage Metrics"),
DT::dataTableOutput("spatial_metrics")  # Remove height parameter
),
br(),
br(),
# Top Locations
div(class = "sidebar-section",
h5("Top 5 Covered Locations"),
DT::dataTableOutput("top_locations")  # Remove height parameter
)
),
),
mainPanel(
width = 8,
leafletOutput("map", height = "100vh")
),
),
)
)
# Server
server <- function(input, output) {
# Grid plot for articles
output$grid_plot_articles <- renderPlot({
ggplot(grid_data, aes(x = col, y = -row)) +
geom_tile(aes(fill = articles_n), color = "white") +
facet_wrap(~owner, ncol = 4) +
scale_fill_gradient(
low = "#d4d4c5",
high = "#2f3e46",
name = "Number of Articles",
na.value = "white",
limits = c(0, 8427),
breaks = c(0, 500, 2000, 5000, 8427),  # Fewer breaks
guide = guide_colorbar(
show.limits = TRUE,
title.position = "top",
title.hjust = 0.5,
barwidth = unit(5, "cm"),  # Make legend wider
barheight = unit(0.5, "cm")
)
) +
theme_void() +
theme(
legend.position = "bottom",
strip.text = element_text(size = 12),
panel.spacing = unit(0.5, "lines")
)
})
output$metrics_table <- DT::renderDataTable({
DT::datatable(
metrics_definitions,
options = list(
pageLength = 8,
searching = FALSE,
info = FALSE,
paging = FALSE,
ordering = FALSE
),
rownames = FALSE
) %>%
DT::formatStyle(
"Dimension",
backgroundColor = "#f8f9fa",
fontWeight = "bold"
) %>%
DT::formatStyle(
columns = 1:4,
fontSize = "12px",  # Smaller font
padding = "4px"     # Less padding
)
})
# Reactive data filtering
filtered_data <- reactive({
req(input$outlet != "")
# Get all data for the outlet
outlet_data <- data[data$domain == input$outlet,]
# Remove rows with missing coordinates
outlet_data <- outlet_data[!is.na(outlet_data$Latitude) & !is.na(outlet_data$Longitude),]
# Validate that we have data
validate(
need(nrow(outlet_data) > 0, "No data available for selected filters")
)
return(outlet_data)
})
# Get outlet metadata
outlet_metadata <- reactive({
req(input$outlet != "")
outlet_info <- data[data$domain == input$outlet,][1,]
return(outlet_info)
})
# Outlet information display
output$outlet_info <- renderUI({
info <- outlet_metadata()
HTML(paste0(
"<strong>Domain:</strong> ", info$domain, "<br>",
"<strong>Title:</strong> ", info$TITLE, "<br>",
"<strong>Owner:</strong> ", info$owner.x, "<br>",
"<strong>Registered Address:</strong> ", info$REGISTERED_ADDRESS, "<br>",
"<strong>Office Address:</strong> ", info$OFFICE_ADDRESS, "<br>",
"<strong>Primary Location:</strong> ", info$primary_location.x, "<br>",
"<strong>Coverage Area:</strong> ", info$coverage_area_description, "<br>"
))
})
output$spatial_metrics <- DT::renderDataTable({
info <- outlet_metadata()
data <- filtered_data()
metrics_data <- data.frame(
Metric = c("Total Articles", "Number of Locations", "Cluster", "Area (km²)", "Radius (km)", "Districts", "Entropy", "Gini", "Moran's I", "Distance CV", "Within 10km (%)"),
Value = c(
info$articles_n,
nrow(unique(data[c("Latitude", "Longitude")])),
info$New_cluster_name,
round(info$Area, 1),
round(info$Radius, 1),
info$Districts,
round(info$Entropy, 3),
round(info$Gini, 3),
round(info$MoranI, 3),
round(info$DistCV, 3),
paste0(round(info$Pct10km, 1), "%")
)
)
DT::datatable(metrics_data,
options = list(pageLength = 10, searching = FALSE,
info = FALSE, paging = FALSE, ordering = FALSE),
rownames = FALSE)
})
output$top_locations <- DT::renderDataTable({
data <- filtered_data()
# Count unique articles per location using resolved_url as unique identifier
location_counts <- data %>%
group_by(value) %>%
summarise(Stories = n_distinct(resolved_url), .groups = 'drop') %>%
arrange(desc(Stories)) %>%
head(5) %>%
rename(Location = value)
DT::datatable(location_counts,
options = list(pageLength = 5, searching = FALSE,
info = FALSE, paging = FALSE, ordering = FALSE),
rownames = FALSE)
})
# Main Map (with zoom limits and no world repetition)
output$map <- renderLeaflet({
if(input$outlet == "") {
leaflet(options = leafletOptions(
worldCopyJump = FALSE,    # Prevents world repetition
maxBoundsViscosity = 1.0  # Makes bounds "sticky"
)) %>%
addProviderTiles("CartoDB.Positron") %>%
setView(lng = 2.5, lat = 55.3, zoom = 6) %>%
setMaxBounds(
lng1 = -180, lat1 = -85,  # Southwest corner
lng2 = 180, lat2 = 85     # Northeast corner
)
} else {
outlet_data <- filtered_data()
outlet_info <- outlet_metadata()
# Create base map with options
map <- leaflet(options = leafletOptions(
worldCopyJump = FALSE,    # Prevents world repetition
maxBoundsViscosity = 1.0, # Makes bounds "sticky"
minZoom = 2,              # Minimum zoom level
maxZoom = 18              # Maximum zoom level
)) %>%
addProviderTiles("CartoDB.Positron")
if(nrow(outlet_data) > 0) {
# Calculate bounds with padding
lng_range <- range(outlet_data$Longitude)
lat_range <- range(outlet_data$Latitude)
# Add padding to bounds (adjust these values as needed)
lng_padding <- diff(lng_range) * 0.1  # 10% padding
lat_padding <- diff(lat_range) * 0.1  # 10% padding
# Set bounds with padding
bounds_lng1 <- max(-180, lng_range[1] - lng_padding)
bounds_lat1 <- max(-85, lat_range[1] - lat_padding)
bounds_lng2 <- min(180, lng_range[2] + lng_padding)
bounds_lat2 <- min(85, lat_range[2] + lat_padding)
map <- map %>%
fitBounds(
lng1 = lng_range[1], lat1 = lat_range[1],
lng2 = lng_range[2], lat2 = lat_range[2]
) %>%
setMaxBounds(
lng1 = bounds_lng1, lat1 = bounds_lat1,
lng2 = bounds_lng2, lat2 = bounds_lat2
)
# Add heatmap (fixed settings)
if(nrow(outlet_data) > 5) {
map <- map %>%
addHeatmap(
data = outlet_data,
lng = ~Longitude, lat = ~Latitude,
radius = 20,
blur = 15,
max = 0.05,
gradient = c("0.0" = "#542788", "0.5" = "#fee0b6", "1.0" = "#b35806")
)
}
# Add story points (fixed settings)
map <- map %>%
addCircleMarkers(
data = outlet_data,
lng = ~Longitude, lat = ~Latitude,
radius = 0.8,
fillOpacity = 0.4,
color = "#2c3e50",
stroke = FALSE,
popup = ~paste0("<b>Story Location</b><br>",
"Coordinates: ", round(Latitude, 3), ", ", round(Longitude, 3), "<br>",
"URL: <a href='", resolved_url, "' target='_blank'>",
substr(resolved_url, 1, 50), "...</a>")
)
# Add outlet location (fixed settings)
if(!is.na(outlet_info$outlet_lat) && !is.na(outlet_info$outlet_lon)) {
map <- map %>%
addMarkers(
lng = outlet_info$outlet_lon, lat = outlet_info$outlet_lat,
popup = paste0("<b>", outlet_info$domain, "</b><br>",
outlet_info$primary_location.x, "<br>",
"Owner: ", outlet_info$owner.x),
icon = makeIcon(
iconUrl = "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png",
iconWidth = 25, iconHeight = 41,
iconAnchorX = 12, iconAnchorY = 41
)
)
}
} else {
# If no data, set global bounds
map <- map %>%
setMaxBounds(
lng1 = -180, lat1 = -85,
lng2 = 180, lat2 = 85
)
}
map
}
})
# Clear map when outlet changes
observe({
if(input$outlet == "") {
leafletProxy("map") %>% clearShapes() %>% clearMarkers()
}
})
}
shinyApp(ui = ui, server = server)
# Server
server <- function(input, output) {
# Grid plot for articles
output$grid_plot_articles <- renderPlot({
ggplot(grid_data, aes(x = col, y = -row)) +
geom_tile(aes(fill = articles_n), color = "white") +
facet_wrap(~owner, ncol = 4) +
scale_fill_gradient(
low = "#d4d4c5",
high = "#2f3e46",
name = "Number of Articles",
na.value = "white",
limits = c(0, 8427),
breaks = c(0, 500, 2000, 5000, 8427),  # Fewer breaks
guide = guide_colorbar(
show.limits = TRUE,
title.position = "top",
title.hjust = 0.5,
barwidth = unit(5, "cm"),  # Make legend wider
barheight = unit(0.5, "cm")
)
) +
theme_void() +
theme(
legend.position = "bottom",
strip.text = element_text(size = 12),
panel.spacing = unit(0.5, "lines")
)
})
output$metrics_table <- DT::renderDataTable({
DT::datatable(
metrics_definitions,
options = list(
pageLength = 8,
searching = FALSE,
info = FALSE,
paging = FALSE,
ordering = FALSE
),
rownames = FALSE
) %>%
DT::formatStyle(
"Dimension",
backgroundColor = "#f8f9fa",
fontWeight = "bold"
) %>%
DT::formatStyle(
columns = 1:4,
fontSize = "12px",  # Smaller font
padding = "4px"     # Less padding
)
})
# Reactive data filtering
filtered_data <- reactive({
req(input$outlet != "")
# Get all data for the outlet
outlet_data <- data[data$domain == input$outlet,]
# Remove rows with missing coordinates
outlet_data <- outlet_data[!is.na(outlet_data$Latitude) & !is.na(outlet_data$Longitude),]
# Validate that we have data
validate(
need(nrow(outlet_data) > 0, "No data available for selected filters")
)
return(outlet_data)
})
# Get outlet metadata
outlet_metadata <- reactive({
req(input$outlet != "")
outlet_info <- data[data$domain == input$outlet,][1,]
return(outlet_info)
})
# Outlet information display
output$outlet_info <- renderUI({
info <- outlet_metadata()
HTML(paste0(
"<strong>Domain:</strong> ", info$domain, "<br>",
"<strong>Title:</strong> ", info$TITLE, "<br>",
"<strong>Owner:</strong> ", info$owner.x, "<br>",
"<strong>Registered Address:</strong> ", info$REGISTERED_ADDRESS, "<br>",
"<strong>Office Address:</strong> ", info$OFFICE_ADDRESS, "<br>",
"<strong>Primary Location:</strong> ", info$primary_location.x, "<br>",
"<strong>Coverage Area:</strong> ", info$coverage_area_description, "<br>"
))
})
output$spatial_metrics <- DT::renderDataTable({
info <- outlet_metadata()
data <- filtered_data()
metrics_data <- data.frame(
Metric = c("Total Articles", "Number of Locations", "Cluster", "Area (km²)", "Radius (km)", "Districts", "Entropy", "Gini", "Moran's I", "Distance CV", "Within 10km (%)"),
Value = c(
info$articles_n,
nrow(unique(data[c("Latitude", "Longitude")])),
info$New_cluster_name,
round(info$Area, 1),
round(info$Radius, 1),
info$Districts,
round(info$Entropy, 3),
round(info$Gini, 3),
round(info$MoranI, 3),
round(info$DistCV, 3),
paste0(round(info$Pct10km, 1), "%")
)
)
DT::datatable(metrics_data,
options = list(pageLength = 10, searching = FALSE,
info = FALSE, paging = FALSE, ordering = FALSE),
rownames = FALSE)
})
output$top_locations <- DT::renderDataTable({
data <- filtered_data()
# Count unique articles per location using resolved_url as unique identifier
location_counts <- data %>%
group_by(value) %>%
summarise(Stories = n_distinct(resolved_url), .groups = 'drop') %>%
arrange(desc(Stories)) %>%
head(5) %>%
rename(Location = value)
DT::datatable(location_counts,
options = list(pageLength = 5, searching = FALSE,
info = FALSE, paging = FALSE, ordering = FALSE),
rownames = FALSE)
})
# Main Map (simplified - fixed settings)
output$map <- renderLeaflet({
if(input$outlet == "") {
leaflet() %>%
addProviderTiles("CartoDB.Positron") %>%
setView(lng = 2.5, lat = 55.3, zoom = 6)
} else {
outlet_data <- filtered_data()
outlet_info <- outlet_metadata()
# Create base map
map <- leaflet() %>%
addProviderTiles("CartoDB.Positron")
if(nrow(outlet_data) > 0) {
map <- map %>%
fitBounds(
lng1 = min(outlet_data$Longitude), lat1 = min(outlet_data$Latitude),
lng2 = max(outlet_data$Longitude), lat2 = max(outlet_data$Latitude)
)
# Add heatmap (fixed settings)
if(nrow(outlet_data) > 5) {
map <- map %>%
addHeatmap(
data = outlet_data,
lng = ~Longitude, lat = ~Latitude,
radius = 20,
blur = 15,
max = 0.05,
gradient = c("0.0" = "#542788", "0.5" = "#fee0b6", "1.0" = "#b35806")
)
}
# Add story points (fixed settings)
map <- map %>%
addCircleMarkers(
data = outlet_data,
lng = ~Longitude, lat = ~Latitude,
radius = 0.8,
fillOpacity = 0.4,
color = "#2c3e50",
stroke = FALSE,
popup = ~paste0("<b>Story Location</b><br>",
"Coordinates: ", round(Latitude, 3), ", ", round(Longitude, 3), "<br>",
"URL: <a href='", resolved_url, "' target='_blank'>",
substr(resolved_url, 1, 50), "...</a>")
)
# Add outlet location (fixed settings)
if(!is.na(outlet_info$outlet_lat) && !is.na(outlet_info$outlet_lon)) {
map <- map %>%
addMarkers(
lng = outlet_info$outlet_lon, lat = outlet_info$outlet_lat,
popup = paste0("<b>", outlet_info$domain, "</b><br>",
outlet_info$primary_location.x, "<br>",
"Owner: ", outlet_info$owner.x),
icon = makeIcon(
iconUrl = "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png",
iconWidth = 25, iconHeight = 41,
iconAnchorX = 12, iconAnchorY = 41
)
)
}
}
map
}
})
# Clear map when outlet changes
observe({
if(input$outlet == "") {
leafletProxy("map") %>% clearShapes() %>% clearMarkers()
}
})
}
shinyApp(ui = ui, server = server)
library(shiny)
library(leaflet)
library(leaflet.extras)
library(sf)
library(dplyr)
library(ggplot2)
library(DT)
library(geosphere)
library(paletteer)
library(bslib)
library(thematic)
library(googlesheets4)
gs4_deauth()
data <- readRDS('analysis_data1.rds')
outlet_list <- unique(data$domain)
data3 <- readRDS("analysis_small.rds")
outlet_info <- googlesheets4::read_sheet(
ss = "https://docs.google.com/spreadsheets/d/1Y1xGVuFqMzaKnbQAQFgaIdgVJ1Ciik3UV5ougUzxXXE/edit?gid=1038895799#gid=1038895799",
sheet = "domains_w_coverage_geocoded"
) %>%
dplyr::select(
domain,
articles_n,
owner,
coverage_area_description,
primary_location,
lat,
lon,
scope
)
outlets_clustered <- googlesheets4::read_sheet(
ss = "https://docs.google.com/spreadsheets/d/1Y1xGVuFqMzaKnbQAQFgaIdgVJ1Ciik3UV5ougUzxXXE/edit?gid=1038895799#gid=1038895799",
sheet = "clustering_results"
) %>%
dplyr::select(1:10)
View(outlets_clustered)
colnameas(outlets_clustered)
colnames(outlets_clustered)
outlets_clustered <- googlesheets4::read_sheet(ss = "https://docs.google.com/spreadsheets/d/1Y1xGVuFqMzaKnbQAQFgaIdgVJ1Ciik3UV5ougUzxXXE/edit?gid=1038895799#gid=1038895799", sheet = "clustering_results") %>%
dplyr::select(c(
"Domain",
"Area",
"Radius",
"Districts",
"Entropy",
"Gini",
"MoranI",
"DistCV"
))
# Add ranks
outlets_clustered <- outlets_clustered %>%
mutate(
gini_rank = rank(-Gini),
convex_rank = rank(-Area),
radius_rank = rank(-Radius),
lsoa_rank = rank(-Districts),
morans_rank = rank(-MoranI),
location_rank = rank(-DistCV),
entropy_rank = rank(-Entropy),
)
View(outlets_clustered)
install.packages("languageserver")
